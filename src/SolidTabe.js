/*
auto-generated by: https://github.com/react-spring/gltfjsx
*/

import * as THREE from 'three';
import React, { useRef, useEffect, useState, useMemo } from 'react';
import { useLoader } from 'react-three-fiber';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { TextureLoader } from 'three/src/loaders/TextureLoader';
import { useTexture } from '@react-three/drei';

import { useSnapshot } from 'valtio';
import store from './store';
import { Controls, useControl, withControls } from 'react-three-gui';
import { MeshBasicMaterial, MeshStandardMaterial } from 'three';

export default function Model(props) {
	console.log('component Mount');
	const snap = useSnapshot(store);
	const group = useRef();
	const baseBoardRef = useRef();

	const { nodes, materials } = useLoader(GLTFLoader, '/SolidTabe4.gltf');
	// const [
	// 	colourMap,
	// 	displacementMap,
	// 	normalMap,
	// 	roughnessMap,
	// 	aoMap,
	// ] = useTexture([
	// 	'/textures/Wood_007_COLOR.jpg',
	// 	'/textures/Wood_007_DISP.png',
	// 	'/textures/Wood_007_NORM.jpg',
	// 	'/textures/Wood_007_ROUGH.jpg',
	// 	'/textures/Wood_007_OCC.jpg',
	// ]);

	const [colourMap, displacementMap, normalMap, roughnessMap] = useTexture([
		'./Wood051_1K_Color.jpg',
		'./Wood051_1K_Displacement.jpg',
		'./Wood051_1K_Normal.jpg',
		'./Wood051_1K_Roughness.jpg',
	]);
	const [cover, setCover] = useState(false);
	console.log(colourMap, displacementMap, normalMap, roughnessMap);

	const legMaterial = useMemo(
		() =>
			new MeshStandardMaterial({ color: snap.modelFactors.steelColour }),
		[snap.modelFactors.steelColour]
	);
	const cupMaterial = useMemo(
		() =>
			new MeshStandardMaterial({ color: snap.modelFactors.steelColour }),
		[snap.modelFactors.steelColour]
	);
	// const materials.Oak = new MeshStandardMaterial({
	// 	color: snap.modelFactors.timberColour,
	// });

	const {
		getPos,
		getScaleWithOffset,
		getScale,
		getEdge,
		getPosOffset,
	} = snap.functions;
	const { scale, borderScale } = snap.transforms;
	const {
		topper,
		legs,
		table,
		TopSetF2: { z: borderWidth },
		TopSetF2,
		TopSetL2,
		LegFL,
		InnerF,
		InnerL,
		cups,
		matColour,
	} = snap.modelFactors;

	const matMaterial = useMemo(
		() =>
			new MeshStandardMaterial({
				map: colourMap,
				displacementMap: displacementMap,
				roughnessMap: roughnessMap,
				normalMap: normalMap,

				color: matColour,
			}),
		[matColour]
	);
	useEffect(() => {
		// getNames(nodes);
		// group.current.castShadow = true;
		// group.current.receiveShadow = true;
		// baseBoardRef.current.geometry.attributes.uv.normalized = true;

		console.log(nodes.BaseBoard);
	}, []);

	useEffect(() => {}, [snap.transforms]);
	return (
		<group ref={group} {...props} dispose={null}>
			<group name={'Front'}>
				<group
					name={'Front Scale'}
					position-z={-getPos(table.z, scale.z)}
				>
					<mesh
						visible={topper == 'inset' ? true : false}
						position-z={-getEdge(table.z, borderScale)}
						scale-x={getScaleWithOffset(
							table.x,
							borderWidth,
							borderScale,
							scale.x
						)}
						scale-z={borderScale}
						material={materials.Oak}
						geometry={nodes.TopSetF2.geometry}
					></mesh>
					<mesh
						position-z={-getEdge(table.z, borderScale)}
						scale-x={getScaleWithOffset(
							table.x,
							borderWidth,
							borderScale,
							scale.x
						)}
						scale-z={borderScale}
						visible={topper == 'cover' ? true : false}
						material={materials.Oak}
						geometry={nodes.TopCovF2.geometry}
					/>
					<mesh
						position-z={getPosOffset(borderWidth, borderScale)}
						scale-x={getScaleWithOffset(
							table.x,
							borderWidth,
							borderScale,
							scale.x
						)}
						material={materials.Oak}
						geometry={nodes.InnerF.geometry}
					/>
					<mesh
						scale-x={getScaleWithOffset(
							table.x,
							LegFL.x,
							1,
							scale.x
						)}
						material={materials.Oak}
						geometry={nodes.RailF.geometry}
					/>
				</group>
			</group>
			<group name={'Back'}>
				<group
					name={'Back Scale'}
					position-z={getPos(table.z, scale.z)}
				>
					<mesh
						visible={topper == 'inset' ? true : false}
						scale-x={getScaleWithOffset(
							table.x,
							borderWidth,
							borderScale,
							scale.x
						)}
						position-z={getEdge(table.z, borderScale)}
						scale-z={borderScale}
						material={materials.Oak}
						geometry={nodes.TopSetB2.geometry}
					/>
					<mesh
						visible={topper == 'cover' ? true : false}
						position-z={getEdge(table.z, borderScale)}
						scale-z={borderScale}
						scale-x={getScaleWithOffset(
							table.x,
							borderWidth,
							borderScale,
							scale.x
						)}
						material={materials.Oak}
						geometry={nodes.TopCovB2.geometry}
					/>
					<mesh
						scale-x={getScaleWithOffset(
							table.x,
							borderWidth,
							borderScale,
							scale.x
						)}
						position-z={-getPosOffset(borderWidth, borderScale)}
						material={materials.Oak}
						geometry={nodes.InnerB.geometry}
					/>
					<mesh
						scale-x={getScaleWithOffset(
							table.x,
							LegFL.x,
							1,
							scale.x
						)}
						material={materials.Oak}
						geometry={nodes.RailB.geometry}
					/>
				</group>
			</group>
			<group name={'Right'}>
				<group
					name={'Right Scale'}
					position-x={-getPos(table.x, scale.x)}
				>
					<mesh
						visible={topper == 'inset' ? true : false}
						position-x={-getEdge(table.x, borderScale)}
						scale-x={borderScale}
						scale-z={getScaleWithOffset(
							table.z,
							borderWidth,
							borderScale,
							scale.z
						)}
						material={materials.Oak}
						geometry={nodes.TopSetR2.geometry}
					/>
					<mesh
						position-x={getPosOffset(borderWidth, borderScale)}
						scale-z={getScaleWithOffset(
							table.z,
							borderWidth,
							borderScale,
							scale.z
						)}
						material={materials.Oak}
						geometry={nodes.InnerR.geometry}
					/>
					<mesh
						visible={topper == 'cover' ? true : false}
						position-x={-getEdge(table.x, borderScale)}
						scale-x={borderScale}
						scale-z={getScaleWithOffset(
							table.z,
							borderWidth,
							borderScale,
							scale.z
						)}
						material={materials.Oak}
						geometry={nodes.TopCovR2.geometry}
					/>
					<mesh
						scale-z={getScaleWithOffset(
							table.z,
							LegFL.z,
							1,
							scale.z
						)}
						material={materials.Oak}
						geometry={nodes.RailR.geometry}
					/>
				</group>
			</group>
			<group name={'Left'}>
				<group
					name={'Left Scale'}
					position-x={getPos(table.x, scale.x)}
				>
					<mesh
						visible={topper == 'inset' ? true : false}
						position-x={getEdge(table.x, borderScale)}
						scale-x={borderScale}
						scale-z={getScaleWithOffset(
							table.z,
							borderWidth,
							borderScale,
							scale.z
						)}
						material={materials.Oak}
						geometry={nodes.TopSetL2.geometry}
					/>
					<mesh
						position-x={-getPosOffset(borderWidth, borderScale)}
						scale-z={getScaleWithOffset(
							table.z,
							borderWidth,
							borderScale,
							scale.z
						)}
						material={materials.Oak}
						geometry={nodes.InnerL.geometry}
					/>
					<mesh
						visible={topper == 'cover' ? true : false}
						position-x={getEdge(table.x, borderScale)}
						scale-x={borderScale}
						scale-z={getScaleWithOffset(
							table.z,
							borderWidth,
							borderScale,
							scale.z
						)}
						material={materials.Oak}
						geometry={nodes.TopCovL2.geometry}
					/>
					<mesh
						scale-z={getScaleWithOffset(
							table.z,
							LegFL.z,
							1,
							scale.z
						)}
						material={materials.Oak}
						geometry={nodes.RailL.geometry}
					/>
				</group>
			</group>
			<group name={'Overall Scale'}>
				<group
					name={'coverTopper'}
					visible={cover && topper == 'cover' ? true : false}
					material={materials.Oak}
					onClick={() => setCover(!cover)}
					scale-x={scale.x}
					scale-z={scale.z}
				>
					<mesh
						material={materials.Oak}
						geometry={nodes.CoverR.geometry}
					/>
					<mesh
						material={materials.Oak}
						geometry={nodes.CoverML.geometry}
					/>
					<mesh
						material={materials.Oak}
						geometry={nodes.CoverMR.geometry}
					/>
					<mesh
						material={materials.Oak}
						geometry={nodes.CoverL.geometry}
					/>
					<group name={'twoPieceCover'}>
						<mesh
							material={materials.Oak}
							geometry={nodes.CoverFillL.geometry}
						/>
						<mesh
							material={materials.Oak}
							geometry={nodes.CoverFillR.geometry}
						/>
					</group>
					<group name={'threePieceCover'}>
						<mesh
							material={materials.Oak}
							geometry={nodes.CoverFillC.geometry}
						/>
					</group>
				</group>
				<group
					name={'insetTopper'}
					visible={cover && topper == 'inset' ? true : false}
					scale-x={getScaleWithOffset(
						table.x,
						borderWidth,
						borderScale,
						scale.x
					)}
					scale-z={getScaleWithOffset(
						table.z,
						borderWidth,
						borderScale,
						scale.z
					)}
				>
					<mesh
						visible={table.x * scale.x > 1450 ? false : true}
						material={materials.Oak}
						geometry={nodes.InsetTopFill.geometry}
					/>
					<mesh
						material={materials.Oak}
						geometry={nodes.InsetTopR.geometry}
					/>
					<mesh
						material={materials.Oak}
						geometry={nodes.InsetTopL.geometry}
					/>
				</group>

				<mesh
					ref={baseBoardRef}
					// scale-x={scale.x}
					// scale-z={scale.z}
					// geometry-uv-normalized={true}
					geometry={nodes.BaseBoard.geometry}
				>
					<meshStandardMaterial
						color={matColour}
						map={colourMap}
						displacementMap={displacementMap}
						// normalMap={normalMap}
						roughnessMap={roughnessMap}
					/>
				</mesh>
			</group>
			<group name={'Corners'}>
				<group
					name={'BackLeftCorner'}
					position-z={getPos(table.z, scale.z)}
					position-x={getPos(table.x, scale.x)}
				>
					<group
						name="topPiecesBR"
						scale-x={borderScale}
						scale-z={borderScale}
						position-x={getEdge(table.x, borderScale)}
						position-z={getEdge(table.z, borderScale)}
					>
						<mesh
							visible={topper == 'inset' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopSetL1.geometry}
						/>
						<mesh
							visible={topper == 'inset' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopSetB3.geometry}
						/>
						<mesh
							visible={topper == 'cover' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopCovB3.geometry}
						/>
						<mesh
							visible={topper == 'cover' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopCovL1.geometry}
						/>
					</group>
					<mesh
						material={materials.Oak}
						geometry={nodes.BLLegBlock.geometry}
					/>
					<mesh
						position-z={-getPosOffset(borderWidth / 2, borderScale)}
						position-y={topper == 'cover' ? -9 : 0}
						position-x={-getPosOffset(borderWidth, borderScale)}
						visible={cups}
						material={cupMaterial}
						geometry={nodes.CupBL.geometry}
					/>
					<mesh
						position-x={-getPosOffset(borderWidth / 2, borderScale)}
						position-z={-getPosOffset(borderWidth, borderScale)}
						position-y={topper == 'cover' ? -9 : 0}
						visible={cups}
						material={cupMaterial}
						geometry={nodes.CupLB.geometry}
					/>

					<mesh
						visible={legs == 'Timber' ? true : false}
						material={materials.Oak}
						geometry={nodes.LegBL.geometry}
					/>

					<mesh
						visible={legs == 'Steel' ? true : false}
						material={legMaterial}
						geometry={nodes.SteelLegBL.geometry}
					/>
				</group>
				<group
					name={'BackRightCorner'}
					position-z={getPos(table.z, scale.z)}
					position-x={-getPos(table.x, scale.x)}
				>
					<group
						name="topPiecesBR"
						scale-x={borderScale}
						scale-z={borderScale}
						position-x={-getEdge(table.x, borderScale)}
						position-z={getEdge(table.z, borderScale)}
					>
						<mesh
							visible={topper == 'cover' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopCovR3.geometry}
						/>
						<mesh
							visible={topper == 'inset' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopSetR3.geometry}
						/>

						<mesh
							visible={topper == 'inset' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopSetB1.geometry}
						/>
						<mesh
							visible={topper == 'cover' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopCovB1.geometry}
						/>
					</group>

					<mesh
						material={materials.Oak}
						geometry={nodes.BRLegBlock.geometry}
					/>
					<mesh
						position-z={-getPosOffset(borderWidth / 2, borderScale)}
						position-x={getPosOffset(borderWidth, borderScale)}
						position-y={topper == 'cover' ? -9 : 0}
						visible={cups}
						material={cupMaterial}
						geometry={nodes.CupBR.geometry}
					/>
					<mesh
						position-x={getPosOffset(borderWidth / 2, borderScale)}
						position-z={-getPosOffset(borderWidth, borderScale)}
						position-y={topper == 'cover' ? -9 : 0}
						visible={cups}
						material={cupMaterial}
						geometry={nodes.CupRB.geometry}
					/>
					<mesh
						visible={legs == 'Timber' ? true : false}
						material={materials.Oak}
						geometry={nodes.LegBR.geometry}
					/>
					<mesh
						visible={legs == 'Steel' ? true : false}
						material={legMaterial}
						geometry={nodes.SteelLegBR.geometry}
					/>
				</group>
				<group
					name={'FrontLeftCorner'}
					position-z={-getPos(table.z, scale.z)}
					position-x={getPos(table.x, scale.x)}
				>
					{' '}
					<group
						name="topPiecesFL"
						scale-x={borderScale}
						scale-z={borderScale}
						position-x={getEdge(table.x, borderScale)}
						position-z={-getEdge(table.z, borderScale)}
					>
						<mesh
							visible={topper == 'inset' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopSetF1.geometry}
						/>
						<mesh
							visible={topper == 'inset' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopSetL3.geometry}
						/>
						<mesh
							visible={topper == 'cover' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopCovF1.geometry}
						/>
						<mesh
							visible={topper == 'cover' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopCovL3.geometry}
						/>
					</group>
					<mesh
						material={materials.Oak}
						geometry={nodes.FLLegBlock.geometry}
					/>
					<mesh
						position-x={-getPosOffset(borderWidth / 2, borderScale)}
						position-z={getPosOffset(borderWidth, borderScale)}
						position-y={topper == 'cover' ? -9 : 0}
						visible={cups}
						material={cupMaterial}
						geometry={nodes.CupLF.geometry}
					/>
					<mesh
						position-z={getPosOffset(borderWidth / 2, borderScale)}
						position-x={-getPosOffset(borderWidth, borderScale)}
						position-y={topper == 'cover' ? -9 : 0}
						visible={cups}
						material={cupMaterial}
						geometry={nodes.CupFL.geometry}
					/>
					<mesh
						visible={legs == 'Timber' ? true : false}
						material={materials.Oak}
						geometry={nodes.LegFL.geometry}
					/>
					<mesh
						visible={legs == 'Steel' ? true : false}
						material={legMaterial}
						geometry={nodes.SteelLegFL.geometry}
					/>
				</group>
				<group
					name={'FrontRightCorner'}
					name={'legFR'}
					position-z={-getPos(table.z, scale.z)}
					position-x={-getPos(table.x, scale.x)}
				>
					<group
						name="topPiecesBR"
						scale-x={borderScale}
						scale-z={borderScale}
						position-x={-getEdge(table.x, borderScale)}
						position-z={-getEdge(table.z, borderScale)}
					>
						<mesh
							visible={topper == 'cover' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopCovR1.geometry}
						/>
						<mesh
							visible={topper == 'cover' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopCovF3.geometry}
							material-color={snap.modelFactors.timberColour}
						/>
						<mesh
							visible={topper == 'inset' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopSetF3.geometry}
						/>
						<mesh
							visible={topper == 'inset' ? true : false}
							material={materials.Oak}
							geometry={nodes.TopSetR1.geometry}
						/>
					</group>

					<mesh
						material={materials.Oak}
						geometry={nodes.FRLegBlock.geometry}
					/>
					<mesh
						position-z={getPosOffset(borderWidth / 2, borderScale)}
						position-x={getPosOffset(borderWidth, borderScale)}
						position-y={topper == 'cover' ? -9 : 0}
						visible={cups}
						material={cupMaterial}
						geometry={nodes.CupFR.geometry}
					/>
					<mesh
						position-x={getPosOffset(borderWidth / 2, borderScale)}
						position-z={getPosOffset(borderWidth, borderScale)}
						position-y={topper == 'cover' ? -9 : 0}
						visible={cups}
						material={cupMaterial}
						geometry={nodes.CupRF.geometry}
					/>
					<mesh
						visible={legs == 'Timber' ? true : false}
						material={materials.Oak}
						geometry={nodes.LegFR.geometry}
					/>
					<mesh
						visible={legs == 'Steel' ? true : false}
						material={legMaterial}
						geometry={nodes.SteelLegFR.geometry}
					/>
				</group>
			</group>
		</group>
	);
}
